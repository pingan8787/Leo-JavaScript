最近开始努力研究算法，遇到这个很有意思的题目，因为从中复习到斐波那契数列，又通过某篇资料，查到中科院官网，看了很多科普文章。深挖下去能看到很多东西。

本着热爱分享的初衷，整理本文与大家分享，题目本身没啥难度，欢迎一起交流，算法大佬求不喷，多谢。

进入主题。

------

本题为 [LeetCode第70题爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)，题目如下：

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**大家可以先想想**。

![](https://images.pingan8787.com/images/20210805/cover.jpg)

## 流程分析

本题中，可以每次可以走 1 级，也可以一次走 2 级，因此我们会有 3 种走法：

- 全程任意走，如全部 1 级走；
- 前面任意走，最后一步只走 1 级；
- 前面任意走，最后一步只走 2 级；

我画了几张图方便大家理解，如下：

![](https://images.pingan8787.com/images/20210805/s1.png)

第一种走法就不做详细介绍。

第二种走法，倒数第二步的走法如下，有 1 步和 2 步两种方式：

![](https://images.pingan8787.com/images/20210805/s2.png)

第三种走法，倒数第二步的走法如下，也有 1 步和 2 步两种方式：

![](https://images.pingan8787.com/images/20210805/s3.png)

上面这个过程描述的是，从最后一层开始往下的每一层的走法。

在最后一步时，有 1 步和 2 步两种方式，可以理解为只能 1 步或者 2 步到达最后一层。

- 当最后一步为 1 步时，即从 n-1 层开始；
- 当最后一步为 2 步时，即从 n-2 层开始；

再理解一下这个过程，就是第 n 层的走法数量是第 n-1 层和第 n-2 层走法数量之和。

如果还不太理解，可以再看看前面的图。

## 归纳法分析

当然，遇事不决，归纳法走起，我们可以列举几种情况进行分析：

| 台阶层数 | 走法数量 | 走法 |
| :---: | :---: | :---: |
| **1** | 1 | 1 |
| **2** | 2 | 11、2 |
| **3** | 3 | 111、12、21 |
| **4** | 5 | 1111、112、121、211、22 |
| **5** | 8 | 11111、1112、1121、1211、2111、221、212、122 |
| **...** | ... | ... |

可以发现有个简单的规律，当台阶层数为 n 层，它的走法数量就有 n-1 层的走法数量加上 n-2 层的走法数量。

记做：`f(n)=f(n-1)+f(n-2)`。

第 1 层固定 1 种走法；
第 2 层固定 2 种走法；
...
第 5 层走法的数量等于第 4 层加上第 5 层走法数量。

理解清楚整个流程规律以后，我们就可以编码就简单多了：

## 解法1：循环累加计算

通过简单的循环累加就能得到结果：

```javascript
const climbStairs = (n = 1) => {
    if(n <= 2) return n;
    let res = 0, n1 = 1, n2 = 2; // n1 表示前 2 项，n2 表示前 1 项
    for(let i = 3; i<= n; i++){  // 前两项值固定，因此从第 3 项开始循环
        res = n1 + n2;
        n1 = n2;
        n2 = res;
    }
    return res;
}
```

测试下第 6 层的走法数量：

```javascript
climbStairs(6); // 13
```

## 解法2：递归计算

按照 `f(n)=f(n-1)+f(n-2)`，这个方法更加简单：

```javascript
const climbStairs = (n = 1) => {
    if(n <= 2) return n;
    return climbStairs(n-1) + climbStairs(n-2);
}
```

测试下第 6 层的走法数量：

```javascript
climbStairs(6); // 13
```

这个方法比较简洁易懂，但递归比较费时，容易出现 LeetCode 超出时间限制的提示。

## 解法3：利用数组特性

利用 `f(n)=f(n-1)+f(n-2)` 这个规律，先预设好前 2 项，再开始循环，最后返回数组最后一项即可：

```js
const climbStairs = n => {
    let result = [1,2];
    for (let i = 2; i < n; i++) {
        result.push(result[i-1] + result[i-2]);
    }
    return result[n-1];
};
```

## 解法4：利用 JavaScript ES6 新特性

利用数组结构赋值操作： `[a, b] = [c, d]`：

```js
const climbStairs = n => {
    let a = b = 1;
    for (let i = 0; i < n; i++) {
        [a, b] = [b, a + b];
    }
    return a;
};
```

当然，大家还有其他解法，欢迎一起讨论~

## 拓展知识：每次可以走 1 步、2 步、3 步

这里多增加了一次可以走 3 步，这时候最后一步会有以下情况：

- 当最后一步为 1 步时，即从 n-1 层开始；
- 当最后一步为 2 步时，即从 n-2 层开始；
- 当最后一步为 3 步时，即从 n-3 层开始；

改造一下前面解法，还是一样：

```javascript
const climbStairs = (n = 1) => {
    if(n <= 2) return n;
  	if(n == 3) return 4;
    return climbStairs(n-1) + climbStairs(n-2) + climbStairs(n-3);
}
```

测试下第 6 层的走法数量：

```javascript
climbStairs(6); // 24
```

## 拓展知识：斐波那契数列
这一题主要考察的内容类似[斐波那契数列（Fibonacci sequence）](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)的计算，如果你还不清楚什么是斐波那契数列，这边先简单介绍一下，另外推荐[李永乐老师讲解的斐波那契的课](https://www.bilibili.com/video/BV1is411E7df?from=search&seid=8645707287599730898)。

最早是有由数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入的，数列大致如：0、1、1、2、3、5、8、13、21、34、....。
认真观察，我们可以发现一个规律：**从第 3 项开始，每一项的值都等于前两项之和**。

在自然界中，存在着许许多多的斐波那契数列的排列方式，比如一棵普通的树，它的树枝生长情况就像下面这样：

![](https://images.pingan8787.com/images/20210805/1.jpg)

（图片来源网络）

可以看到每一层枝干的数量为 1、2、3、5、8、...排列下去。当然还有很多其他的：

![](https://images.pingan8787.com/images/20210805/2.png)

（自然界中各种各样的裴波那契螺旋，图片来源于网络）

根据斐波那契数列的规律，得到这样的公式 `f(n)=f(n-1)+f(n-2)` 。跟我们前面列的差不多。

## 总结

这道题本身难度不大，但是如果没有理清流程和规律，很容易掉坑，写多余的代码。本文只列举两个简单实现方法，如果大家有其他实现方式，欢迎一起讨论~哈哈。