> [阅读原文 obkoro1.com](http://obkoro1.com/2018/07/08/JS%E9%AB%98%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/)

### 内存的生命周期：  
1. 分配你所需要的内存：   

由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会**分配内存来存储那个实体**。  

2. 使用分配到的内存做点什么。  

3. 不需要时将其释放回归：  

在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是**垃圾回收机制所存在的意义**。  

**所谓的内存泄漏**指的是：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。  
***
### 垃圾回收机制：
在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。    

### 垃圾收集机制的原理：
垃圾收集器会按照固定的时间间隔，**周期性的找出不再继续使用的变量，然后释放其占用的内存**。  

#### 什么叫不再继续使用的变量？

不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。  

全局变量的生命周期直至浏览器卸载页面才会结束，也就是说**全局变量不会被当成垃圾回收**。

### 标记清除：当前采用的垃圾收集策略
工作原理：

当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：

1. 垃圾收集器会在运行的时候会给存储在内存中的**所有变量都加上标记**。
2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。
3. 那些还存在标记的变量被视为准备删除的变量。
4. 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。
到2008年为止,IE、Chorme、Fireofx、Safari、Opera **都使用标记清除式的垃圾收集策略**，只不过垃圾收集的时间间隔互有不同。

### 引用计数略：被废弃的垃圾收集策
循环引用：跟踪记录每个值被引用的技术

在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。

COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。
```js
var element = document.getElementById('something');
var myObject = new Object();
myObject.element = element; // element属性指向dom
element.someThing = myObject; // someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。
```
解决方式是，当我们不使用它们的时候，手动切断链接：
```js
myObject.element = null; 
element.someThing = null;
```
#### 淘汰：

IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。

IE7以下有一个声明狼藉的性能问题，大家了解一下：

1. 256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。
2. 如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。
IE7已修复这个问题。
***

### 哪些情况会引起内存泄漏？
虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。  

#### 意外的全局变量：
上文我们提到了**全局变量不会被当成垃圾回收**，我们在编码中有时会出现下面这种情况：
```js
function foo() {
 this.bar2 = '默认绑定this指向全局' // 全局变量=> window.bar2
  bar = '全局变量'; // 没有声明变量 实际上是全局变量=>window.bar
}
foo();
```
当我们使用[默认绑定](https://juejin.im/post/5b3715def265da59af40a630#heading-3)，this会指向全局，`this.something`也会创建一个全局变量，这一点可能很多人没有注意到。

**解决方法：在函数内使用严格模式or细心一点**
```js
function foo() {
  "use strict"; 
  this.bar2 = "严格模式下this指向undefined"; 
  bar = "报错";
}
foo();
```
当然我们也可以手动释放全局变量的内存：
```js
window.bar = undefined
delete window.bar2
```
#### 被遗忘的定时器和回调函数
当不需要`setInterval`或者`setTimeout`时，**定时器没有被clear**，定时器的**回调函数以及内部依赖的变量都不能被回收**，造成内存泄漏。
```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
        // 定时器也没有清除
    }
    // node、someResource 存储了大量数据 无法回收
}, 1000);
```
**解决方法**： 在定时器完成工作的时候，手动清除定时器。

### 闭包：
**闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。**
```js
function bindEvent() {
  var obj = document.createElement("XXX");
  var unused = function () {
      console.log(obj,'闭包内引用obj obj不会被释放');
  };
  // obj = null;
}
```
**解决方法**：手动解除引用，`obj = null`。

#### 循环引用问题
就是IE9以下的循环引用问题，上文讲过了。

#### 没有清理DOM元素引用：
```js
var refA = document.getElementById('refA');
document.body.removeChild(refA); // dom删除了
console.log(refA, "refA");  // 但是还存在引用 能console出整个div 没有被回收
```
不信的话，可以看下这个[dom](https://codepen.io/OBKoro1/pen/vroKbg)。

**解决办法**：`refA = null`;

#### console保存大量数据在内存中。
过多的console，比如定时器的console会导致浏览器卡死。

**解决**：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘，除外。
***
### 如何避免内存泄漏：
**记住一个原则：不用的东西，及时归还，毕竟你是’借的’嘛。**

1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量。
2. 在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。
3. 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。
#### 关于内存泄漏：
1. 即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。
2. 一般是堆区内存泄漏，栈区不会泄漏。
基本类型的值存在内存中，被保存在栈内存中，引用类型的值是**对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏**。

3. 使用chorme监控内存泄漏，可以看一下[这篇文章](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)
